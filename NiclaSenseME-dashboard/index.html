<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->

    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script>
    <script src="GLTFLoader.js"></script>

    <title>Sensor page</title>
</head>

<body>
    <style>
        * {
            font-family: 'Roboto Mono', sans-serif;
        }

        body {
            color: white;
            background: #000000;
            font-size: 14px;
        }

        #pairButton {
            background-color: #d8f41d;
            border: none;
            color: black;
            padding: 1px;
            text-align: center;
            text-decoration: none;

            margin: 8px 18px;
            height: 25px;
            width: 100px;
            border-radius: 10%;
            outline: none;

            border-radius: 20px;
            grid-column: 1;

            cursor: pointer;
        }

        .container {
            width: 960px;

            margin-top: 30px;
            margin-bottom: 7.5px;
            margin: 0 auto;
        }

        .widget {
            background-color: #111111;
            border: 1px solid #000000;
            border-radius: 0px;
            padding: 12px;
            margin: 6px;
            float: left;
            color: #DAE3E3;
            padding-bottom: 16px;

        }

        a {
            color: white;
            font-weight: bold;
        }

        .status {
            margin-top: 1%;
            width: 885px;
            height: 42px;
            color: white;
            display: grid;
            grid-template-columns: 15% 70% 15%;
        }

        #bluetooth {
            font-size: 16px;
            height: 50%;
            margin: auto;
        }

        .square {
            width: 192px;
            height: 226px;
            position: relative;
        }

        .label {
            height: 15px;
            display: inline;
            font-size: 12px;

        }

        .statusBar {
            height: 100%;
            grid-column: 2;
            vertical-align: middle;
            text-align: center;
        }

        .digit {
            font-size: 20px;
            color: #888888;
            float: right;
        }

        .short {
            width: 192px;
            height: 92px;
        }

        .double {
            width: 423px;
            height: 226px;
        }

        .graph {
            width: 192px;
            height: 177px;
        }

        .doublegraph {
            width: 423px;
            height: 177px;
        }

        .shortgraph {
            width: 192px;
            height: 81px;
        }

        .quaternion {
            font-size: 10px;
        }

        #color-picker-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            margin: auto;
        }

        #snackbar {
            height: 23px;
            display: block;
            visibility: visible;
            text-align: center;
            background-color: #374146;
            border-radius: 3px;
            padding: 4px 13px 4px 13px;
            margin: 16px 7px 7px;

            display: inline-block;

        }

        #canvasDigits {
            width: 75%;
            margin: auto;
        }

        #canvasDigits span {
            width: 29%;
            display: inline-block;
        }

        #snackbar.show {

            -webkit-animation: fadein 0.5s, 0.1s;
            animation: fadein 0.5s, 0.1s;
        }


        @-webkit-keyframes fadein {
            from {
                visibility: hidden;

                opacity: 0;
            }

            to {
                visibility: visible;

                opacity: 1;
            }
        }

        @keyframes fadein {
            from {
                visibility: hidden;

                opacity: 0;
            }

            to {
                visibility: visible;

                opacity: 1;
            }
        }
    </style>
    </head>

    <body>
        <div class="container">

            <div id="snackbar"></div>
            <div class="status widget">
                <button id="pairButton">CONNECT</button>
                <div class="label statusBar" id="bluetooth">Click the connect button to connect your device</div>
                <img src="Logo-Arduino-Pro-inline.svg"
                    style="position: inherit;padding-right: 0px;filter: invert(100%);float: right; grid-column: 3; width: 80%; margin-top: 8.5%;" />
            </div>

            <div class="square widget" id="3d">
                <div class="label">&#128230; Quaternion Rotation</div>
                <div class="quaternion" id="canvasDigits">
                    <span id="xQuaternion">x: -</span>
                    <span id="yQuaternion">y: -</span>
                    <span id="zQuaternion">z: -</span>
                </div>
            </div>

            <div class="double widget">
                <div class="label">&#128640; Accelerometer</div>
                <div id="accelerometer" class="doublegraph"></div>
            </div>

            <div class="square widget">
                <div class="label">&#128171; Gyroscope</div>
                <div class="label" id="gyroscope-value"></div>
                <div id="gyroscope" class="graph"></div>
            </div>

            <div class="square widget">
                <div class="label">&#128161; RGB LED control</div>
                <div id="color-picker-container" class="graph"></div>
            </div>

            <div class="short widget">
                <div class="label">&#127777; Temperature - </div>
                <div class="label" id="temperature-value"></div>
                <div class="label">&deg;C</div>
                <div class="shortgraph" id="temperature"></div>
            </div>

            <div class="short widget">
                <div class="label">&#128167; Humidity - </div>
                <div class="label" id="humidity-value"></div>
                <div class="label">%</div>
                <div class="shortgraph" id="humidity"></div>

            </div>

            <div class="short widget">
                <div class="label">&#9925; Pressure - </div>
                <div class="label" id="pressure-value"></div>
                <div class="label">hPa</div>
                <div class="shortgraph" id="pressure"></div>
            </div>

            <div class="short widget">
                <div class="label">&#127968; Indoor Air Quality - </div>
                <div class="label" id="bsec-value"></div>
                <div class="label"></div>
                <div class="shortgraph" id="bsec"></div>
            </div>

            <div class="short widget">
                <div class="label">&#127793; Co2 Value -</div>
                <div class="label" id="co2-value"></div>
                <div class="label"></div>
                <div class="shortgraph" id="co2"></div>
            </div>

            <div class="short widget">
                <div class="label">&#x1F4A8; Gas Value -</div>
                <div class="label" id="gas-value"></div>
                <div class="label"></div>
                <div class="shortgraph" id="gas"></div>
            </div>

        </div>

        <!-- Configuration form -->

        <!-- Read sensor data form -->
        <div class="container text-center">
            <input id="" type="button" value="Debug table" onclick="toggleTable(this);"
                style="background-color: gray;" />

            <table id="dataTable" class="table table-bordered"
                style="table-layout:auto; width:100%; visibility: hidden;">
                <thead>
                    <tr>
                        <th scope="col" style="width: 10%;">Sensor ID</th>
                        <th scope="col" style="width: 14%;">Sensor Name</th>
                        <th scope="col" style="width: 25%;">Data</th>
                        <th scope="col" style="width: 7%;">Status</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            </table>
        </div>

        <!-- Optional JavaScript -->
        <!-- jQuery first, then Popper.js, then Bootstrap JS -->
        <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
            integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n"
            crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"
            integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo"
            crossorigin="anonymous"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"
            integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6"
            crossorigin="anonymous"></script>
    </body>

</html>

<script>

    const deviceName = 'NICLA'
    const sensorServiceUuid = '34c2e3bb-34aa-11eb-adc1-0242ac120002';
    const sensorConfigCharacteristicUuid = '34c2e3bd-34aa-11eb-adc1-0242ac120002';
    const sensorDataCharacteristicUuid = '34c2e3bc-34aa-11eb-adc1-0242ac120002';
    const sensorLongDataCharacteristicUuid = '34c2e3be-34aa-11eb-adc1-0242ac120002';

    var bleDevice
    var bleServer
    var sensorService
    var sensorConfigCharacteristic
    var sensorDataCharacteristic
    var sensorLongDataCharacteristic

    var sensorMap = new Map();
    var parseScheme;
    var sensorTypes;
    var sensorTypesLen;

    const pairButton = document.getElementById('pairButton');
    const BLEstatus = document.getElementById('bluetooth');

    // 3d model
    var renderer = new THREE.WebGLRenderer();
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, 1, 1, 10000);

    const sensors = [115, 130, 131, 129, 128, 133, 4, 13, 34];

    snack('IMPORTANT - first upload the Arduino_BHY2/app.ino sketch', 1)
    init3D();

    fetch("./parse-scheme.json")
        .then(response => response.json())
        .then(json => {
            console.log(json);
            parseScheme = json;
        });

    fetch("./sensor-type-map.json")
        .then(response => response.json())
        .then(json => {
            console.log(json);
            sensorTypes = json;
            var counter = 0;
            sensorTypesLen = Object.keys(sensorTypes).length;
            console.log("Json length: ", sensorTypesLen);
            fillSensorTable();
        });


    document.querySelector('#pairButton').addEventListener('click', function () {
        if (isWebBluetoothEnabled()) {

            connect()
                .then(_ => {
                    console.log('Connected')
                    document.querySelector('#configureButton').disabled = false
                })
                .catch(error => {
                    console.log('ERROR: ' + error);
                })
                .then(_ => {

                    for (var i = 0; i < sensors.length; i++) {
                        console.log(sensors[i])
                        startSensor(sensors[i])
                        setTimeout(() => {
                            console.log("Delayed for 1 second.")
                            initializeSensor();
                            sensorsInitialized++;
                        }, 4000 + 500 * i)
                    }
                });
        }
    });

    var sensorsInitialized = 0;
    function initializeSensor() {
        enableSensor(sensors[sensorsInitialized]);
    }
    function floatToBytes(value) {
        var tempArray = new Float32Array(1);
        tempArray[0] = value;
        return new Uint8Array(tempArray.buffer);
    }

    function intToBytes(value) {
        var tempArray = new Int32Array(1);
        tempArray[0] = value;
        return new Uint8Array(tempArray.buffer);
    }

    function isWebBluetoothEnabled() {
        if (!navigator.bluetooth) {
            console.log('Web Bluetooth is NOT available!')
            return false
        }
        console.log('Web Bluetooth is available!')
        return true
    }

    function getDeviceInfo() {
        let options = {
            filters: [{ services: [sensorServiceUuid] }]
        };
        console.log('Requesting BLE device info...');
        return navigator.bluetooth.requestDevice(options).then(device => {
            bleDevice = device
        }).catch(error => {
            console.log('Request device error: ' + error)
        });
    }
    // Top middle information label
    function msg(m) {
        BLEstatus.innerHTML = m;
    }

    //Top left pop up messaage
    function snack(m, warningLevel) {
        snackBar = document.getElementById("snackbar");
        snackBar.style.visibility = "visible";
        snackBar.className = "show";

        var warnEmoji = warningLevel ? '☝️  ' : '✅  ';

        setTimeout(function () { snackBar.className = snackBar.className.replace("show", ""); }, 501);
        snackBar.innerHTML = warnEmoji + m + ' <span onClick=hideSnack() style="cursor:pointer; margin-left: 15px"> ✖ </span> ';
    }

    function hideSnack() {
        snackBar = document.getElementById("snackbar");
        snackBar.style.visibility = "hidden";
    }
    function connect() {
        return getDeviceInfo()
            .then(msg('connecting to device ...'))
            .then(connectDevice)
            .then(getSensorCharacteristics)
            .then(onConnection);
    }

    function connectDevice() {
        pairButton.style.backgroundColor = "grey";
        pairButton.style.color = 'black';
        pairButton.innerHTML = "PAIRING";

        console.log('Connecting to device')

        bleDevice.addEventListener('gattserverdisconnected', onDisconnection);
        return bleDevice.gatt.connect()
            .then(server => {
                bleServer = server;
                return bleServer.getPrimaryService(sensorServiceUuid);
            })
            .then(service => {
                sensorService = service;
            })
            .then(msg('getting BLE characteristics ...'));

    }

    function onDisconnection(event) {
        var status = document.getElementById("connectionStatus");
        status.innerHTML = "Disconnected";
        status.className = "badge rounded-pill bg-danger";
    }

    function onConnection() {
        msg('Connected');
        pairButton.style.backgroundColor = 'green';
        pairButton.style.color = 'white';
        pairButton.innerHTML = "PAIRED";
        var status = document.getElementById("connectionStatus");
        status.innerHTML = "Connected";
        status.className = "badge rounded-pill bg-success";
    }

    function getSensorCharacteristics() {
        console.log('Getting sensor characteristics');
        return sensorService.getCharacteristic(sensorConfigCharacteristicUuid)
            .then(characteristic => {
                sensorConfigCharacteristic = characteristic;
            })
            .then(_ => {
                return sensorService.getCharacteristic(sensorDataCharacteristicUuid);
            })
            .then(characteristic => {
                sensorDataCharacteristic = characteristic;
                sensorDataCharacteristic.startNotifications();
                sensorDataCharacteristic.addEventListener('characteristicvaluechanged', receiveSensorData)
            })
            .then(_ => {
                return sensorService.getCharacteristic(sensorLongDataCharacteristicUuid);
            })
            .then(characteristic => {
                sensorLongDataCharacteristic = characteristic;
                sensorLongDataCharacteristic.startNotifications();
                sensorLongDataCharacteristic.addEventListener('characteristicvaluechanged', receiveSensorData)
            });
    }

    function toggleTable(_this) {
        table = document.getElementById("dataTable")
        if (_this.style.backgroundColor == "limegreen") {
            table.style.visibility = "hidden";
            _this.style.backgroundColor = "gray";
        } else {
            table.style.visibility = "visible";
            _this.style.backgroundColor = "limegreen";
        }
    }
    function updateSensorStatus(_this, sensor) {

        if (_this.style.backgroundColor == "limegreen") {
            //Turn sensor OFF
            disableSensor(sensor);
            _this.style.backgroundColor = "";
        } else {
            //Turn sensor ON
            enableSensor(sensor);
            _this.style.backgroundColor = "limegreen";
        }
    }

    function configureSensor(id, sampleRate, latency) {
        var configPacket = new Uint8Array(9);
        configPacket[0] = id;
        configPacket.set(floatToBytes(sampleRate), 1);
        configPacket.set(intToBytes(latency), 5);
        //console.log(configPacket);

        sensorConfigCharacteristic.writeValue(configPacket)
            .then(_ => {
                console.log('Configuration written');
            });
    }
    function disableSensor(id) {
        var configPacket = new Uint8Array(9);
        configPacket[0] = id;
        console.log("Disable sensor ", id);
        configPacket.set(floatToBytes(0), 1);
        configPacket.set(intToBytes(0), 5);
        console.log(configPacket);
        sensorConfigCharacteristic.writeValue(configPacket)
            .then(_ => {
                console.log('Configuration written');
            });
    }

    function enableSensor(id) {
        var configPacket = new Uint8Array(9);
        configPacket[0] = id;
        console.log("Enable sensor ", id);
        configPacket.set(floatToBytes(1), 1);
        console.log(configPacket);
        sensorConfigCharacteristic.writeValue(configPacket)
            .then(_ => {
                console.log('Configuration written');
            });
    }

    function startSensor(sensorID, rate, latency) {
        console.log("Starting sensor " + sensorTypes[sensorID].name);
        configureSensor(sensorID, rate, latency);
        disableSensor(sensorID);

        enableSensor(sensorID);
        tableInsert(sensorID);
    }

    function tableInsert(sensorId) {
        //Handle individual Enabled buttons
        var table = document.getElementById("dataTable");
        if (sensorMap.has(sensorId)) {
            rowIndex = sensorMap.get(sensorId);
            var row = table.rows[rowIndex];
            row.cells[3].firstChild.style.backgroundColor = "limegreen";
        } else {
            var tableLength = table.rows.length;
            sensorMap.set(sensorId, tableLength);
            var row = table.insertRow(tableLength);
            var cell = row.insertCell(0);
            cell.innerHTML = sensorId;
            cell = row.insertCell(1);
            cell.innerHTML = sensorTypes[sensorId].name;
            cell = row.insertCell(2);
            cell.innerHTML = 0;
            cell = row.insertCell(3);
            cell.innerHTML = '<input id="Button" type="button" value="Enabled" onclick="updateSensorStatus(this, \'' + sensorId + '\');"/>'
            row.cells[3].firstChild.style.backgroundColor = "limegreen";

        }
    }
    function fillSensorTable() {
        var table = document.getElementById("dataTable");
        var tableLength = table.rows.length;

        for (let i = 0; i < sensorTypesLen - 1; i++) {
            var key = Object.keys(sensorTypes)[i];
            if (sensorTypes[key].dashboard == 1) {
                var tableLength = table.rows.length;
                var sensorIdx = parseInt(key)
                sensorMap.set(sensorIdx, tableLength);
                var row = table.insertRow(tableLength);
                var cell = row.insertCell(0);
                cell.innerHTML = key;
                cell = row.insertCell(1);
                cell.innerHTML = sensorTypes[key].name;
                cell = row.insertCell(2);
                cell.innerHTML = 0;
                cell = row.insertCell(3);
                cell.innerHTML = '<input id="Button" type="button" value="Enabled" onclick="updateSensorStatus(this, \'' + sensorIdx + '\');"/>'
                //cell = row.insertCell(4);
                //var chartIdx = sensorTypes[sensorIdx].name;
                //cell.innerHTML = '<div id=\'' + chartIdx + '\'></div>';
            }
        }
    }

    a = []; b = []; c = [];

    function receiveSensorData(event) {
        var value = event.target.value;
        // Get sensor data
        var sensor = value.getUint8(0);
        var size = value.getUint8(1);
        //console.log(value)
        var parsedData = parseData(sensor, value);
        parsedName = parsedData[0]
        parsedStringValue = parsedData[1]
        parsedValue = parsedData[2]
        console.log("Received " + parsedName);

        var table = document.getElementById("dataTable");
        const colors = ["#FF355E", "#FD5B20", "#FF6037", "#FF9966", "#FF9933", "#FFCC33", "#FFFF66", "#FFFF66", "#CCFF00", "#66FF66", "#AAF0D1", "#50BFE6", "#FF6EFF", "#EE34D2", "#FF00CC", "#FF00CC"];
        var colorIndex = 0;

        // If sensor is already in the table -> update its value
        if (sensorMap.has(sensor)) {
            rowIndex = sensorMap.get(sensor);
            var row = table.rows[rowIndex];
            var cell = row.cells[0];
            cell.innerHTML = sensor;
            cell = row.cells[1];
            cell.innerHTML = parsedName;

            cell = row.cells[2];
            cell.innerHTML = parsedStringValue;

            //cell = row.cells[4];
            var chartIdx = document.getElementById(parsedName);

            var cnt = 0;

            if (sensorTypes[sensor].scheme == "singleRead") {

                //Initial condition to draw the first chart point
                if (sensorTypes[sensor].value == 0) {   //Plot doesn't exist yet because no valid data have been received
                    if (parsedValue != 0) {   //First valid data received: draw it in the chart

                        Plotly.plot(chartIdx, [{
                            y: [parsedValue],
                            mode: 'lines',
                            showticklabels: false,
                            width: 1,
                            line: { width: 1 }
                        }],
                            {

                                plot_bgcolor: '#111111',
                                paper_bgcolor: '#111111',
                                margin: { l: 8, r: 8, b: 18, t: 18 },
                                showlegend: false,
                                yaxis: { 'showticklabels': false },
                                xaxis: {
                                    'range': [0, 64],
                                    'showticklabels': false,
                                    'autorange': false,
                                    'showgrid': true,
                                    'zeroline': true,
                                    tickfont: { size: 8 }
                                }
                            }
                        );
                        //Update json to signal that the reception started
                        cnt = sensorTypes[sensor].value + 1;
                        sensorTypes[sensor].value = cnt;
                    }
                } else {    //Plot already exists
                    Plotly.extendTraces(chartIdx, { y: [[parsedValue]] }, [0]);
                    cnt = sensorTypes[sensor].value;
                    sensorTypes[sensor].value = cnt + 1;
                }

                if (cnt > 64) {
                    Plotly.relayout(chartIdx, {
                        xaxis: {
                            range: [cnt - 64, cnt]
                        }
                    });
                }

                valueDiv = document.getElementById(parsedName + '-value');
                if (!Number.isNaN(parsedValue)) { valueDiv.innerHTML = Math.round(parsedValue * 10) / 10; };


            } else if (sensorTypes[sensor].scheme == "xyz") {
                //Parse 3D axes values
                const arrXYZValues = parsedStringValue.split(" ");
                /* console.log("Split: ", arrXYZValues);
                 console.log("Split[1]: ", arrXYZValues[1]);
                 console.log("Split[5]: ", arrXYZValues[5]);
                 console.log("Split[9]: ", arrXYZValues[9]);*/

                var split = [arrXYZValues[1], arrXYZValues[5], arrXYZValues[9]];

                var item = ['x', 'y', 'z'];
                var format = [];
                for (var i = 0; i < 3; i++) {
                    colorIndex++;
                    if (colorIndex > colors.length) { colorIndex = 0; }
                    format.push({
                        y: [i],
                        name: item[i],
                        mode: 'lines',
                        width: 1,
                        line: { width: 1, color: colors[colorIndex] }
                    });
                }

                //Initial condition to draw the first chart point
                if (sensorTypes[sensor].value == 0) {   //Plot doesn't exist yet because no valid data have been received
                    if (parsedValue != 0) {   //First valid data received: draw it in the chart

                        Plotly.plot(chartIdx, [{
                            y: [split[0]],
                            mode: 'lines',
                            showticklabels: false,
                            width: 1,
                            line: { width: 1 }
                        }, {
                            y: [split[1]],
                            mode: 'lines',

                            width: 1,
                            line: { width: 1 }
                        }, {
                            y: [split[2]],
                            mode: 'lines',

                            width: 1,
                            line: { width: 1 }
                        }],
                            {

                                plot_bgcolor: '#111111',
                                paper_bgcolor: '#111111',
                                margin: { l: 8, r: 8, b: 18, t: 18 },
                                showlegend: false,
                                yaxis: { 'showticklabels': false },
                                xaxis: {
                                    'range': [0, 64],
                                    'showticklabels': false,
                                    'autorange': false,
                                    'showgrid': true,
                                    'zeroline': true,
                                    tickfont: { size: 8 }
                                }
                            }
                        );

                        //Update json to signal that the reception started
                        cnt = sensorTypes[sensor].value + 1;
                        sensorTypes[sensor].value = cnt;
                    }
                } else {    //Plot already exists
                    Plotly.extendTraces(chartIdx, {
                        y: [[split[0]], [split[1]], [split[2]]]
                    }, [0, 1, 2])
                    cnt = sensorTypes[sensor].value;
                    sensorTypes[sensor].value = cnt + 1
                }

                if (cnt > 64) {
                    Plotly.relayout(chartIdx, {
                        xaxis: {
                            range: [cnt - 64, cnt]
                        }
                    });
                }
            } else if (sensorTypes[sensor].scheme == "BSECOutput") {
                //Parse BSEC values
                const BSECValues = parsedStringValue.split(" ");
                /*console.log("Split: ", BSECValues);
                console.log("Split[1]: ", BSECValues[2]);
                console.log("Split[7]: ", BSECValues[7]);*/

                var val1 = BSECValues[2];
                var val2 = BSECValues[7];

                if (sensorTypes[sensor].value == 0) {   //Plot doesn't exist yet because no valid data have been received
                    if (val1 != 0 && val2 != 0) {   //First valid data received: draw it in the chart
                        Plotly.newPlot(chartIdx, [{ y: [val1], name: 'Temp', type: 'line' }, { y: [val2], name: 'Humidity', type: 'line' }]);
                        //Update json to signal that the reception started
                        cnt = sensorTypes[sensor].value + 1;
                        sensorTypes[sensor].value = cnt;
                    }
                } else {    //Plot already exists
                    Plotly.extendTraces(chartIdx, { y: [[val1]] }, [0]);
                    Plotly.extendTraces(chartIdx, { y: [[val2]] }, [1]);
                    cnt = sensorTypes[sensor].value;
                    sensorTypes[sensor].value = cnt + 1;
                }

                if (cnt > 64) {
                    Plotly.relayout(chartIdx, {
                        xaxis: {
                            range: [cnt - 64, cnt]
                        }
                    });
                }
            } else if (sensorTypes[sensor].scheme == "BSECOutputV2") {
                //Parse BSEC values
                const BSECValues = parsedStringValue.split(" ");
                //console.log("Split: ", BSECValues);

                var val1 = BSECValues[1];   //iaq
                var val2 = BSECValues[5];   //iaq-s
                var val3 = BSECValues[9] * 1000;   //b-voc-eq
                var val4 = BSECValues[13];  //co2-eq
                var val5 = BSECValues[17];  //status

                var iaqDiv = document.getElementById("bsec");
                var iaqDivValue = document.getElementById("bsec-value");
                var co2Div = document.getElementById("co2");
                var co2DivValue = document.getElementById("co2-value");

                if (sensorTypes[sensor].value == 0) {   //Plot doesn't exist yet because no valid data have been received
                    if (val4 != 0) {   //First valid data received: draw it in the chart, valid CO2-eq output is always greater than 0

                        Plotly.plot(iaqDiv, [{
                            y: [val2],
                            mode: 'lines',
                            showticklabels: false,
                            width: 1,
                            line: { width: 1 }
                        }],
                            {

                                plot_bgcolor: '#111111',
                                paper_bgcolor: '#111111',
                                margin: { l: 8, r: 8, b: 18, t: 18 },
                                showlegend: false,
                                yaxis: { 'showticklabels': false },
                                xaxis: {
                                    'range': [0, 64],
                                    'showticklabels': false,
                                    'autorange': false,
                                    'showgrid': true,
                                    'zeroline': true,
                                    tickfont: { size: 8 }
                                }
                            }
                        );

                        Plotly.plot(co2, [{
                            y: [val4],
                            mode: 'lines',
                            showticklabels: false,
                            width: 1,
                            line: { width: 1 }
                        }],
                            {

                                plot_bgcolor: '#111111',
                                paper_bgcolor: '#111111',
                                margin: { l: 8, r: 8, b: 18, t: 18 },
                                showlegend: false,
                                yaxis: { 'showticklabels': false },
                                xaxis: {
                                    'range': [0, 64],
                                    'showticklabels': false,
                                    'autorange': false,
                                    'showgrid': true,
                                    'zeroline': true,
                                    tickfont: { size: 8 }
                                }
                            }
                        );
                        //Update json to signal that the reception started
                        cnt = sensorTypes[sensor].value + 1;
                        sensorTypes[sensor].value = cnt;
                    }

                    iaqDivValue.innerHTML = val2;
                    Plotly.extendTraces(iaqDiv, { y: [[val2]] }, [0]);

                    co2DivValue.innerHTML = val4;
                    Plotly.extendTraces(co2Div, { y: [[val4]] }, [0]);

                    cnt = sensorTypes[sensor].value;
                    sensorTypes[sensor].value = cnt + 1;
                }

                if (cnt > 64) {
                    Plotly.relayout(iaqDiv, {
                        xaxis: {
                            range: [cnt - 64, cnt]
                        }
                    });
                    Plotly.relayout(co2Div, {
                        xaxis: {
                            range: [cnt - 64, cnt]
                        }
                    });
                }

            }
            else if (sensorTypes[sensor].scheme == "quaternion") {
                //Parse BSEC values
                const BSECValues = parsedStringValue.split(" ");
                //console.log("Split: ", BSECValues);

                var x = BSECValues[1];   //iaq
                var y = BSECValues[5];   //iaq-s
                var z = BSECValues[9];   //b-voc-eq
                var w = BSECValues[13];  //co2-eq

                var divX = document.getElementById("xQuaternion");
                var divY = document.getElementById("yQuaternion");
                var divZ = document.getElementById("zQuaternion");

                update3d(x, y, z, w)



            }
        }
    }


    function init3D() {
        var container = document.getElementById('3d');
        var loader = new THREE.GLTFLoader();
        var canvasDigits = document.getElementById('canvasDigits');
        scene.background = new THREE.Color(0x58585A);
        renderer.setSize(177, 177);

        renderer.setPixelRatio(4);

        container.insertBefore(renderer.domElement, canvasDigits);
        renderer.domElement.style.margin = "9px";
        loader.load('models/niclaSenseME.glb',
            // called when the Arduinio model is loaded
            function (gltf) {
                // Model
                arduinoModel = gltf.scene;
                scene.add(arduinoModel);

                // LED
                var geometry = new THREE.BoxGeometry(1, 1, 1);
                ledMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
                ledObject = new THREE.Mesh(geometry, ledMaterial);
                ledObject.position.set(9, -10, -1);

                ledLight = new THREE.PointLight(0x111111, 3, 40);
                ledLight.color.setRGB(0, 255, 0);
                ledLight.position.set(9, -10, -1.2);

                ledMaterial.color.setRGB(0, 255, 0);

                arduinoModel.add(ledObject);
                arduinoModel.add(ledLight);

                arduinoModel.rotation.x = 90 * (Math.PI / 180);  // Show the bottom side of the board by default

                var sphereSize = 1;

                // Light
                const color = 0xFFFFFF;
                const intensity = 1;
                const light = new THREE.DirectionalLight(color, intensity);
                light.position.set(-20, 100, -10);
                light.target.position.set(0, 0, 0);
                scene.add(light);
                scene.add(light.target);
                var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1);
                scene.add(hemiLight);

                // Camera
                camera.position.set(0, 25, 0);
                camera.rotation.y = Math.PI; // 180
                camera.lookAt(new THREE.Vector3(0, 0, 0));
                renderer.render(scene, camera);
            }
        );
    }
    function update3d(x, y, z, w) {
        // Construct the quaternion object with the values and apply that to the 3D model
        const quaternion = new THREE.Quaternion(x, y, z, w);
        quaternion.normalize();
        arduinoModel.setRotationFromQuaternion(quaternion);

        renderer.render(scene, camera);

        // Euler conversion, show the degrees below the 3D model
        var rotation = new THREE.Euler().setFromQuaternion(quaternion, 'XYZ');

        document.getElementById('xQuaternion').innerHTML = "x: " + Math.round(rotation.x * 180 / Math.PI + 180);
        document.getElementById('yQuaternion').innerHTML = "y: " + Math.round(rotation.y * 180 / Math.PI + 180);
        document.getElementById('zQuaternion').innerHTML = "z: " + Math.round(rotation.z * 180 / Math.PI + 180);

        renderer.render(scene, camera);

        // Euler conversion, show the degrees below the 3D model
        var rotation = new THREE.Euler().setFromQuaternion(quaternion, 'XYZ');

        document.getElementById('xQuaternion').innerHTML = "x: " + Math.round(rotation.x * 180 / Math.PI + 180);
        document.getElementById('yQuaternion').innerHTML = "y: " + Math.round(rotation.y * 180 / Math.PI + 180);
        document.getElementById('zQuaternion').innerHTML = "z: " + Math.round(rotation.z * 180 / Math.PI + 180);
    }

    function parseData(sensor, data) {
        var sensorName = sensorTypes[sensor].name;
        var scheme = sensorTypes[sensor].scheme;
        var result = "";
        var parse_scheme;
        var eventcount;
        // dataIndex start from 2 because the first bytes of the packet indicate
        // the sensor id and the data size
        var dataIndex = 0 + 2;
        var value = 0;

        if (scheme == "singleRead") {
            parse_scheme = sensorTypes[sensor]["parse-scheme"];
        } else if (scheme == "quaternion") {
            parse_scheme = parseScheme["types"][0]["parse-scheme"];
        } else if (scheme == "xyz") {
            parse_scheme = parseScheme["types"][1]["parse-scheme"];
        } else if (scheme == "orientation") {
            parse_scheme = parseScheme["types"][2]["parse-scheme"];
        } else if (scheme == "event") {
            eventcount = sensorTypes[sensor].eventcount;
            parse_scheme = parseScheme["types"][3]["parse-scheme"];
        } else if (scheme == "activity") {
            parse_scheme = parseScheme["types"][4]["parse-scheme"];
        } else if (scheme == "BSECOutput") {
            parse_scheme = parseScheme["types"][5]["parse-scheme"];
        } else if (scheme == "BSECOutputV2") {
            var size = data.getUint8(1);
            if (size <= 10) {
                parse_scheme = parseScheme["types"][6]["parse-scheme"];
            } else {
                parse_scheme = parseScheme["types"][7]["parse-scheme"];
            }
        }

        parse_scheme.forEach(element => {
            console.log(element);
            var name = element['name'];
            var valueType = element['type'];
            var scale = element['scale-factor'];
            var size = 0;

            if (valueType == "uint8") {
                value = data.getUint8(dataIndex, true) * scale;
                size = 1;
            } else if (valueType == "int8") {
                value = data.getInt8(dataIndex, true) * scale;
                size = 1;
            } else if (valueType == "uint16") {
                value = data.getUint16(dataIndex, true) * scale;
                size = 2;
            } else if (valueType == "int16") {
                value = data.getInt16(dataIndex, true) * scale;
                size = 2;
            } else if (valueType == "uint24") {
                value = (data.getUint16(dataIndex, true) + (data.getUint8(dataIndex + 2, true) << 16)) * scale;
                size = 3;
            } else if (valueType == "uint32") {
                value = (data.getUint16(dataIndex, true) + (data.getUint16(dataIndex + 2, true) << 16)) * scale;
                size = 4;
            } else if (valueType == "float") {
                value = data.getFloat32(dataIndex, true) * scale;
                size = 4;
            } else if (valueType == "none") {
                value = eventcount + 1;
                sensorTypes[sensor].eventcount = value;
                size = 0;
            } else {
                console.log("Error: unknown type");
            }

            if (scheme == "activity") {
                value = geActivityString(value);
            }
            result = result + element.name + ": " + value + "   ";
            //console.log(dataIndex);
            dataIndex += size;

        });

        return [sensorName, result, value];
    }

    function geActivityString(value) {

        const activityMessages = ["Still activity ended",
            "Walking activity ended",
            "Running activity ended",
            "On bicycle activity ended",
            "In vehicle activity ended",
            "Tilting activity ended",
            "In vehicle still ended",
            "",
            "Still activity started",
            "Walking activity started",
            "Running activity started",
            "On bicycle activity started",
            "In vehicle activity started",
            "Tilting activity started",
            "In vehicle still started",
            ""];

        for (let i = 0; i < 16; i++) {
            maskedVal = (value & (0x0001 << i)) >> i;
            if (maskedVal) {
                console.log(activityMessages[i]);
                return [activityMessages[i]];
            }
        }
    }

</script>